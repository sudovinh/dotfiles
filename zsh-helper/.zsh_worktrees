# Generic git worktree helper functions
# Works with bare-repo worktree setups created by git-clone-bare-for-worktrees

# Find the bare repo root (directory containing .bare/)
_wt_bare_root() {
  local dir="$PWD"
  while [[ "$dir" != "/" ]]; do
    if [[ -d "$dir/.bare" ]]; then
      echo "$dir"
      return 0
    fi
    dir="$(dirname "$dir")"
  done
  echo "Error: not inside a bare-repo worktree setup (no .bare/ found)" >&2
  return 1
}

# Idempotently add extra remotes from WT_EXTRA_REMOTES associative array
# Usage: _wt_ensure_remotes [bare_root_path]
_wt_ensure_remotes() {
  # No-op if WT_EXTRA_REMOTES is not set or empty
  if [[ -z "${(t)WT_EXTRA_REMOTES}" ]] || [[ ${#WT_EXTRA_REMOTES} -eq 0 ]]; then
    return 0
  fi

  local root="${1:-}"
  if [[ -z "$root" ]]; then
    root="$(_wt_bare_root)" || return 1
  fi

  local git_dir="$root/.bare"
  if [[ ! -d "$git_dir" ]]; then
    echo "Error: no .bare/ found at $root" >&2
    return 1
  fi

  local name url
  for name url in "${(@kv)WT_EXTRA_REMOTES}"; do
    # Skip if remote already exists
    if git -C "$git_dir" remote get-url "$name" &>/dev/null; then
      continue
    fi

    echo "Adding remote '$name' → $url"
    git -C "$git_dir" remote add "$name" "$url"

    # Apply custom refspecs if defined
    if [[ -n "${WT_EXTRA_REMOTE_REFSPECS[$name]:-}" ]]; then
      local refspec
      for refspec in ${(s:;:)WT_EXTRA_REMOTE_REFSPECS[$name]}; do
        git -C "$git_dir" config --add "remote.$name.fetch" "$refspec"
      done
    fi

    echo "Fetching '$name'..."
    if ! git -C "$git_dir" fetch "$name" 2>&1; then
      echo "Warning: fetch failed for remote '$name' (remote was still added)" >&2
    fi
  done
}

# wt-remotes — show configured remotes and WT_EXTRA_REMOTES status
wt-remotes() {
  local root
  root="$(_wt_bare_root)" || return 1

  local git_dir="$root/.bare"

  echo "Git remotes in $root:"
  echo ""
  git -C "$git_dir" remote -v | while IFS= read -r line; do
    echo "  $line"
  done

  echo ""

  if [[ -z "${(t)WT_EXTRA_REMOTES}" ]] || [[ ${#WT_EXTRA_REMOTES} -eq 0 ]]; then
    echo "WT_EXTRA_REMOTES: (not configured)"
    return 0
  fi

  echo "WT_EXTRA_REMOTES:"
  local name url
  for name url in "${(@kv)WT_EXTRA_REMOTES}"; do
    local status="missing"
    if git -C "$git_dir" remote get-url "$name" &>/dev/null; then
      status="active"
    fi
    printf "  %-20s %-50s [%s]\n" "$name" "$url" "$status"
  done
}

# wt-add <name> [<branch>] — add a worktree from the bare repo root
# If branch is omitted, creates a new branch with the same name
wt-add() {
  if [[ $# -lt 1 ]]; then
    echo "Usage: wt-add <name> [<branch>]"
    echo "  If branch is omitted, creates a new branch named <name>"
    return 1
  fi

  local root
  root="$(_wt_bare_root)" || return 1

  local name="$1"
  local branch="${2:-}"
  local wt_path="$root/$name"

  if [[ -d "$wt_path" ]]; then
    echo "Error: $wt_path already exists" >&2
    return 1
  fi

  if [[ -n "$branch" ]]; then
    git -C "$root" worktree add "$wt_path" "$branch"
  else
    git -C "$root" worktree add "$wt_path" -b "$name"
  fi

  _wt_ensure_remotes "$root"
}

# wt-rm <name> — remove a worktree with safety check
wt-rm() {
  if [[ $# -lt 1 ]]; then
    echo "Usage: wt-rm <name>"
    return 1
  fi

  local root
  root="$(_wt_bare_root)" || return 1

  local name="$1"
  local wt_path="$root/$name"

  if [[ ! -d "$wt_path" ]]; then
    echo "Error: worktree '$name' not found at $wt_path" >&2
    return 1
  fi

  # Check for uncommitted changes
  if [[ -n "$(git -C "$wt_path" status --porcelain 2>/dev/null)" ]]; then
    echo "Warning: worktree '$name' has uncommitted changes:"
    git -C "$wt_path" status --short
    echo ""
    echo -n "Remove anyway? (y/N) "
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
      echo "Aborted."
      return 1
    fi
  fi

  git -C "$root" worktree remove "$wt_path" --force
  echo "Removed worktree: $name"

  # Clean up the branch if it still exists
  local branch
  branch="$(git -C "$root" branch --list "$name" 2>/dev/null)"
  if [[ -n "$branch" ]]; then
    echo -n "Delete local branch '$name'? (y/N) "
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
      git -C "$root" branch -D "$name"
    fi
  fi
}

# wt-ls — list worktrees with branch, last commit, and status
wt-ls() {
  local root
  root="$(_wt_bare_root)" || return 1

  echo "Worktrees in $root:"
  echo ""

  git -C "$root" worktree list --porcelain | while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        wt_path="${line#worktree }"
        ;;
      branch\ *)
        branch="${line#branch refs/heads/}"
        ;;
      HEAD\ *)
        head="${line#HEAD }"
        ;;
      "")
        if [[ -n "${wt_path:-}" ]]; then
          local name
          name="$(basename "$wt_path")"
          local dirty=""
          if [[ -d "$wt_path" ]] && [[ -n "$(git -C "$wt_path" status --porcelain 2>/dev/null)" ]]; then
            dirty=" [dirty]"
          fi
          local last_commit=""
          if [[ -d "$wt_path" ]]; then
            last_commit="$(git -C "$wt_path" log -1 --format='%cr - %s' 2>/dev/null | head -c 80)"
          fi
          printf "  %-40s %-30s %s%s\n" "$name" "${branch:-detached}" "$last_commit" "$dirty"
        fi
        unset wt_path branch head
        ;;
    esac
  done
}

# wt-inspect — find stale worktrees (>7 days since last commit)
wt-inspect() {
  local root
  root="$(_wt_bare_root)" || return 1

  local stale_days="${1:-7}"
  local stale_seconds=$((stale_days * 86400))
  local now
  now="$(date +%s)"
  local found_stale=false

  echo "Worktrees with no commits in the last ${stale_days} days:"
  echo ""

  git -C "$root" worktree list --porcelain | while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        wt_path="${line#worktree }"
        ;;
      branch\ *)
        branch="${line#branch refs/heads/}"
        ;;
      "")
        if [[ -n "${wt_path:-}" ]] && [[ -d "$wt_path" ]]; then
          local name
          name="$(basename "$wt_path")"
          local last_epoch
          last_epoch="$(git -C "$wt_path" log -1 --format='%ct' 2>/dev/null || echo 0)"
          local age=$(( now - last_epoch ))
          if [[ $age -gt $stale_seconds ]]; then
            local days_ago=$(( age / 86400 ))
            printf "  %-40s %-30s %d days ago\n" "$name" "${branch:-detached}" "$days_ago"
            found_stale=true
          fi
        fi
        unset wt_path branch
        ;;
    esac
  done

  if [[ "$found_stale" == false ]]; then
    echo "  (none)"
  fi
}

# cdwt — cd to the bare repo root
cdwt() {
  local root
  root="$(_wt_bare_root)" || return 1
  cd "$root"
}

# cdz — cd to the current worktree root (top-level of the checkout)
cdz() {
  local toplevel
  toplevel="$(git rev-parse --show-toplevel 2>/dev/null)"
  if [[ -z "$toplevel" ]]; then
    echo "Error: not inside a git working tree" >&2
    return 1
  fi
  cd "$toplevel"
}

# wt-frebase [<base>] — fetch and rebase current worktree on origin/main (or specified base)
wt-frebase() {
  local root
  root="$(_wt_bare_root)" || return 1

  local base="${1:-origin/main}"

  echo "Fetching and rebasing on $base..."
  git -C "$root" fetch -p && git rebase --autostash "$base"
}

# wt-frebase-all [<base>] — fetch and rebase all worktrees on origin/main (or specified base)
wt-frebase-all() {
  local root
  root="$(_wt_bare_root)" || return 1

  local base="${1:-origin/main}"

  echo "Fetching..."
  git -C "$root" fetch -p

  echo ""
  echo "Rebasing all worktrees on $base..."
  echo ""

  git -C "$root" worktree list --porcelain | while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        wt_path="${line#worktree }"
        ;;
      branch\ *)
        branch="${line#branch refs/heads/}"
        ;;
      "")
        if [[ -n "${wt_path:-}" ]] && [[ -d "$wt_path" ]] && [[ -n "${branch:-}" ]]; then
          local name
          name="$(basename "$wt_path")"

          # Skip if it's the bare repo itself
          if [[ "$wt_path" == "$root" ]] || [[ "$name" == ".bare" ]]; then
            unset wt_path branch
            continue
          fi

          echo "→ Rebasing $name ($branch)..."
          if git -C "$wt_path" rebase --autostash "$base" 2>&1; then
            echo "  ✓ Done"
          else
            echo "  ✗ Rebase failed or conflicts — run 'cd $wt_path && git rebase --continue' to resolve"
          fi
          echo ""
        fi
        unset wt_path branch
        ;;
    esac
  done
}

# wt-status — show rebase/merge status for all worktrees
wt-status() {
  local root
  root="$(_wt_bare_root)" || return 1

  echo "Worktree status in $root:"
  echo ""

  git -C "$root" worktree list --porcelain | while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        wt_path="${line#worktree }"
        ;;
      branch\ *)
        branch="${line#branch refs/heads/}"
        ;;
      "")
        if [[ -n "${wt_path:-}" ]] && [[ -d "$wt_path" ]]; then
          local name
          name="$(basename "$wt_path")"

          # Skip bare repo
          if [[ "$name" == ".bare" ]]; then
            unset wt_path branch
            continue
          fi

          local status_flags=""

          # Check for ongoing rebase
          if [[ -d "$wt_path/.git/rebase-merge" ]] || [[ -d "$wt_path/.git/rebase-apply" ]]; then
            status_flags+=" [REBASING]"
          fi

          # Check for merge in progress
          if [[ -f "$wt_path/.git/MERGE_HEAD" ]]; then
            status_flags+=" [MERGING]"
          fi

          # Check for uncommitted changes
          if [[ -n "$(git -C "$wt_path" status --porcelain 2>/dev/null)" ]]; then
            status_flags+=" [dirty]"
          fi

          # Check commits ahead/behind origin/main
          local ahead_behind=""
          ahead_behind="$(git -C "$wt_path" rev-list --left-right --count origin/main...HEAD 2>/dev/null)"
          if [[ -n "$ahead_behind" ]]; then
            local behind="${ahead_behind%%	*}"
            local ahead="${ahead_behind##*	}"
            if [[ "$ahead" -gt 0 ]] || [[ "$behind" -gt 0 ]]; then
              status_flags+=" [↑$ahead ↓$behind]"
            fi
          fi

          printf "  %-30s %-25s%s\n" "$name" "${branch:-detached}" "$status_flags"
        fi
        unset wt_path branch
        ;;
    esac
  done
}

# wt-rebase [<base>] — interactive rebase current worktree on origin/main (like grebase)
wt-rebase() {
  local root
  root="$(_wt_bare_root)" || return 1

  local base="${1:-origin/main}"

  echo "Fetching..."
  git -C "$root" fetch -p

  local real_editor
  if [[ -f "$HOME/.config/dotfiles/git_editor" ]]; then
    real_editor="$(cat "$HOME/.config/dotfiles/git_editor")"
  else
    real_editor="$(git config core.editor)"
  fi

  # If editor is Zed, use --new to avoid session restore showing stale files
  if [[ "$real_editor" == *"zed"* ]]; then
    real_editor="$real_editor --new"
  fi

  if [[ -n "$real_editor" ]]; then
    GIT_EDITOR="$real_editor" git rebase -i --autosquash --autostash "$base"
  else
    echo "No editor available, running non-interactive rebase"
    git rebase --autosquash --autostash "$base"
  fi
}

# wt-push — push current worktree branch to origin
wt-push() {
  git push origin HEAD
}

# wt-pushforce — force push current worktree branch to origin (with lease)
wt-pushforce() {
  git push origin HEAD --force-with-lease
}

# wt-logline — show commits in current worktree since origin/main
wt-logline() {
  local base="${1:-origin/main}"
  git log --oneline "$base"..HEAD
}

# wt-resetcommit — undo last commit in current worktree (keep changes staged)
wt-resetcommit() {
  git reset HEAD~
}

# wt-resetbranch — reset current worktree branch to match remote
wt-resetbranch() {
  local root
  root="$(_wt_bare_root)" || return 1

  local branch_name
  branch_name="$(git rev-parse --abbrev-ref HEAD)"

  if [[ -z "$branch_name" ]]; then
    echo "Error: Unable to determine the current branch." >&2
    return 1
  fi

  echo "Fetching the latest changes from origin..."
  git -C "$root" fetch origin

  echo "Resetting the local branch '$branch_name' to match 'origin/$branch_name'..."
  git reset --hard origin/"$branch_name"

  echo "The local branch '$branch_name' is now in sync with 'origin/$branch_name'."
}

# wt-hardreset — hard reset current worktree to origin/main (like ghardresetmain)
wt-hardreset() {
  local root
  root="$(_wt_bare_root)" || return 1

  local base="${1:-origin/main}"

  echo "Fetching and hard resetting to $base..."
  git -C "$root" fetch origin && git clean -fd && git reset --hard "$base"
}

# wt-cd <name> — cd to a specific worktree by name
wt-cd() {
  if [[ $# -lt 1 ]]; then
    echo "Usage: wt-cd <name>"
    return 1
  fi

  local root
  root="$(_wt_bare_root)" || return 1

  local name="$1"
  local wt_path="$root/$name"

  if [[ ! -d "$wt_path" ]]; then
    echo "Error: worktree '$name' not found at $wt_path" >&2
    echo "Available worktrees:"
    wt-ls
    return 1
  fi

  cd "$wt_path"
}

# wt-main — cd to the main worktree and pull latest
wt-main() {
  local root
  root="$(_wt_bare_root)" || return 1

  local main_wt="$root/main"

  if [[ ! -d "$main_wt" ]]; then
    echo "Error: main worktree not found at $main_wt" >&2
    return 1
  fi

  cd "$main_wt" && git pull origin main
}

# wt-help — show all worktree commands with usage examples
wt-help() {
  cat <<'EOF'
Git Worktree Helper Commands
=============================

Worktree Management:
  wt-add <name> [<branch>]        Add a worktree (new branch if branch omitted)
                                     wt-add my-feature
                                     wt-add hotfix origin/release-1.0

  wt-rm <name>                    Remove a worktree (prompts if dirty)
                                     wt-rm my-feature

  wt-ls                           List all worktrees with branch and last commit
                                     wt-ls

  wt-inspect [<days>]             Find stale worktrees (default: 7 days)
                                     wt-inspect
                                     wt-inspect 14

  wt-status                       Show rebase/merge/dirty status for all worktrees
                                     wt-status

Navigation:
  wt-cd <name>                    cd to a worktree by name
                                     wt-cd my-feature

  wt-main                         cd to main worktree and pull latest
                                     wt-main

  cdwt                            cd to the bare repo root
                                     cdwt

  cdz                             cd to the current worktree root
                                     cdz

Rebase & Sync:
  wt-frebase [<base>]             Fetch + rebase current worktree (default: origin/main)
                                     wt-frebase
                                     wt-frebase origin/release-1.0

  wt-frebase-all [<base>]         Fetch + rebase ALL worktrees
                                     wt-frebase-all

  wt-rebase [<base>]              Interactive rebase current worktree
                                     wt-rebase
                                     wt-rebase origin/main

Push:
  wt-push                         Push current branch to origin
                                     wt-push

  wt-pushforce                    Force push with lease to origin
                                     wt-pushforce

History & Reset:
  wt-logline [<base>]             Show commits since base (default: origin/main)
                                     wt-logline

  wt-resetcommit                  Undo last commit (keep changes staged)
                                     wt-resetcommit

  wt-resetbranch                  Reset current branch to match its remote
                                     wt-resetbranch

  wt-hardreset [<base>]           Hard reset to base (default: origin/main)
                                     wt-hardreset

Remotes:
  wt-remotes                      Show git remotes and WT_EXTRA_REMOTES status
                                     wt-remotes
EOF
}
