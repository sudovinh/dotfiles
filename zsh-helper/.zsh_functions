function updatezsh() {
  current_dir=$(pwd)
  chezmoi update
  cd ~/dev_setup && git pull
  cd $current_dir
  source ~/.zshrc
  refresh-global
}

function code() {
  VSCODE_CWD="$PWD" open -n -b "com.microsoft.VSCode" --args $* ;
}

function _getk8secret(){
  kubectl get secrets $1 -n $2 -o yaml >> $1.yaml
}

function _createk8secret(){
  kubectl create secret generic $2 --from-file=$1 --dry-run=true  --output=yaml > $2.yaml
}

function codezshfiles() {
  local zshfile
  zshfile="$(find $HOME/.local/share/chezmoi/zsh-helper -type f -name '.*' | fzf --height 40% --reverse)"

  if [ -n "$zshfile" ]; then
    code $zshfile
  fi
}

function switchkconfig() {
  local config
  local command
  config="$(ls -1 $HOME/.kube/configs | fzf --height 40% --reverse)"

  if [ -n "$config" ]; then
    export KUBECONFIG="$HOME/.kube/configs/$config"
  fi

  echo "Set kubeconfig to $config"
}

function podsVsNodes() {
    uniqueNodes=$(kubectl get pod -n $1 -o wide | grep -v NAME | sed 's/ \{1,\}/,/g' | sort --unique -t, -k7,7 | wc -l)
    pods=$(kubectl get pod -n $1 | grep -v NAME | wc -l)
    echo "Pods in Namespace: ${pods}\nNodes In Use By Namespace: ${uniqueNodes}"
}

function _knetworktest() {
    if [ -n "$1" ]; then
        img=$1
    else
        img='nicolaka/netshoot:latest'
    fi
    kubectl run vinh-tmp-shell --rm -i --tty -n examples--emojivoto --image=$img --restart=Never -- /bin/bash
}

function _newbashscript() { 
    if [ -z "$2" ]; then 
        cp ~/scripts/template_bash_script "$1/default_script"; 
    else 
        cp ~/scripts/template_bash_script "$1/$2.sh"; 
    fi; 
}

function gitcommit() {
  local commit_type
  commit_type="$(echo -e "feat\nfix\nchore\nrefactor\ndocs\nstyle\ntest\nperf\nci\nbuild\nrevert" | fzf)"

  if [ -n "$commit_type" ]; then
    echo "Selected commit type: $commit_type"
    echo "Enter commit message:"
    read -r commit_message
    if [ -n "$commit_message" ]; then
      git commit -m "$commit_type: $commit_message"
    else
      echo "No commit message entered, exiting."
    fi
  else
    echo "No commit type selected, exiting."
  fi
}

function gitdeletebranches() {
  git for-each-ref --sort=-committerdate refs/remotes/origin/ --format="%(refname:short) %(committerdate:unix)" | \
  grep -v 'origin/HEAD' | grep -v 'origin/main$' | \
  while read -r refname unixtime; do
    now_epoch=$(date +%s)
    age=$(( (now_epoch - unixtime) / 3600 ))
    if [ "$age" -ge 1 ]; then
      branch=${refname#origin/}
      git push origin --delete "$branch"
    fi
  done
}

function aws_profiles() {
  profiles=$(aws --no-cli-pager configure list-profiles 2> /dev/null)
  if [[ -z "$profiles" ]]; then
    echo "No AWS profiles found in '$HOME/.aws/config, check if ~/.aws/config exists and properly configured.'"
    return 1
  else
    echo $profiles
  fi
}

function gresetbranchremote() {
    # Get the current branch name
    local branch_name=$(git rev-parse --abbrev-ref HEAD)

    if [ -z "$branch_name" ]; then
        echo "Error: Unable to determine the current branch."
        return 1
    fi

    echo "Fetching the latest changes from origin..."
    git fetch origin

    echo "Resetting the local branch '$branch_name' to match 'origin/$branch_name'..."
    git reset --hard origin/"$branch_name"

    echo "The local branch '$branch_name' is now in sync with 'origin/$branch_name'."
}

function find_merge() {
  commit=$1
  branch=${2:-HEAD}
  (git rev-list $commit..$branch --ancestry-path | cat -n; git rev-list $commit..$branch --first-parent | cat -n) | sort -k2 -s | uniq -f1 -d | sort -n | tail -1 | cut -f2
}

function show_merge() {
  merge=$(find_merge $1 $2)
  [ -n "$merge" ] && git show $merge
}

function encode2json() {
  if [[ -z "$1" ]]; then
    echo "Usage: encodefile <file-path>"
    return 1
  fi

  if [[ ! -f "$1" ]]; then
    echo "Error: File '$1' not found"
    return 1
  fi

  cat "$1" | base64 | jq -R --arg type "opaque" '{type: $type, value: .}'
}

# thanks ssoriche
# https://github.com/ssoriche/kubectl.fish/blob/main/functions/kubectl-why-not-deleted.fish
function k-why-not-deleted() {
    # Handle help option first
    if [[ " $* " =~ " --help " ]] || [[ " $* " =~ " -h " ]]; then
        echo "kubectl-why-not-deleted - Analyze why a Kubernetes resource is not being deleted"
        echo ""
        echo "USAGE:"
        echo "  kubectl-why-not-deleted RESOURCE NAME [-n NAMESPACE]"
        echo ""
        echo "DESCRIPTION:"
        echo "  This function analyzes why a Kubernetes resource is not being deleted by checking"
        echo "  for finalizers, owner references, dependent resources, and providing actionable"
        echo "  insights. It helps debug stuck deletions by examining the resource's metadata"
        echo "  and relationships with other resources."
        echo ""
        echo "EXAMPLES:"
        echo "  kubectl-why-not-deleted pod my-pod"
        echo "  kubectl-why-not-deleted deployment my-app -n production"
        echo "  kubectl-why-not-deleted pvc my-volume-claim"
        echo "  kubectl-why-not-deleted namespace my-namespace"
        echo ""
        echo "DEPENDENCIES:"
        echo "  - kubectl: Kubernetes command-line tool"
        echo "  - jq: JSON processor for parsing resource metadata"
        echo ""
        echo "INSTALLATION:"
        echo "  # macOS"
        echo "  brew install jq"
        echo ""
        echo "  # Ubuntu/Debian"
        echo "  sudo apt-get install jq"
        return 0
    fi

    # Check if we have the required arguments
    if [[ $# -lt 2 ]]; then
        echo "Error: Insufficient arguments provided" >&2
        echo "Usage: kubectl-why-not-deleted RESOURCE NAME [-n NAMESPACE]" >&2
        echo "Use 'kubectl-why-not-deleted --help' for more information" >&2
        return 1
    fi

    # Check if kubectl is available
    if ! command -v kubectl >/dev/null 2>&1; then
        echo "Error: kubectl is not installed or not in PATH" >&2
        echo "Please install kubectl to use this function" >&2
        return 1
    fi

    # Check if jq is available
    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required but not installed" >&2
        echo "Install with: brew install jq (macOS) or apt-get install jq (Ubuntu)" >&2
        return 1
    fi

    local resource_type="$1"
    local resource_name="$2"
    local namespace_args=""

    # Convert common plural resource types to singular
    case "$resource_type" in
        jobs) resource_type="job" ;;
        pods) resource_type="pod" ;;
        deployments) resource_type="deployment" ;;
        services) resource_type="service" ;;
        configmaps) resource_type="configmap" ;;
        secrets) resource_type="secret" ;;
        persistentvolumeclaims|pvcs) resource_type="persistentvolumeclaim" ;;
        namespaces) resource_type="namespace" ;;
        replicasets) resource_type="replicaset" ;;
        statefulsets) resource_type="statefulset" ;;
        daemonsets) resource_type="daemonset" ;;
        ingresses) resource_type="ingress" ;;
        services) resource_type="service" ;;
        endpoints) resource_type="endpoints" ;;
        events) resource_type="events" ;;
        nodes) resource_type="node" ;;
        persistentvolumes|pvs) resource_type="persistentvolume" ;;
        storageclasses) resource_type="storageclass" ;;
        clusterroles) resource_type="clusterrole" ;;
        clusterrolebindings) resource_type="clusterrolebinding" ;;
        roles) resource_type="role" ;;
        rolebindings) resource_type="rolebinding" ;;
        serviceaccounts) resource_type="serviceaccount" ;;
        crds) resource_type="crd" ;;
        customresourcedefinitions) resource_type="customresourcedefinition" ;;
    esac

    # Parse namespace argument if provided
    shift 2  # Remove the first two arguments (resource_type and resource_name)
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--namespace)
                if [[ $# -gt 1 ]]; then
                    namespace_args="-n$2"
                    shift 2
                else
                    echo "Error: -n/--namespace requires a value" >&2
                    return 1
                fi
                ;;
            *)
                shift
                ;;
        esac
    done

    echo "üîç Analyzing why $resource_type/$resource_name is not being deleted..."
    echo ""

    # Get the resource in JSON format
    local resource_json
    local kubectl_exit_status
    resource_json=$(kubectl get "$resource_type" "$resource_name" $namespace_args -o json 2>/dev/null)
    kubectl_exit_status=$?

    if [[ $kubectl_exit_status -ne 0 ]]; then
        echo "‚ùå Error: Could not find $resource_type/$resource_name"
        if [[ -z "$namespace_args" ]]; then
            echo "   Try specifying a namespace with -n <namespace>"
        fi
        return 1
    fi

    # Check if resource is marked for deletion
    local deletion_timestamp
    deletion_timestamp=$(kubectl get "$resource_type" "$resource_name" $namespace_args -o jsonpath='{.metadata.deletionTimestamp}' 2>/dev/null)
    
    # Also check for finalizers to see if they exist
    local finalizers_check
    finalizers_check=$(kubectl get "$resource_type" "$resource_name" $namespace_args -o jsonpath='{.metadata.finalizers}' 2>/dev/null)

    if [[ -z "$deletion_timestamp" ]] || [[ "$deletion_timestamp" == "null" ]]; then
        echo "‚ÑπÔ∏è  Resource is NOT marked for deletion"
        echo "   The resource has not received a delete request yet."
        echo "   Use 'kubectl delete $resource_type $resource_name -n ${namespace_args#-n}' to delete it."
        return 0
    fi

    echo "üóëÔ∏è  Resource IS marked for deletion (since: $deletion_timestamp)"
    echo ""

    # Check for finalizers
    local finalizers
    finalizers=$(kubectl get "$resource_type" "$resource_name" $namespace_args -o jsonpath='{.metadata.finalizers[*]}' 2>/dev/null)

    if [[ -n "$finalizers" ]]; then
        echo "üîí FINALIZERS blocking deletion:"
        echo "$finalizers" | tr ' ' '\n' | while read -r finalizer; do
            if [[ -n "$finalizer" ]]; then
                echo "   ‚Ä¢ $finalizer"
            fi
        done
        echo ""
        echo "üí° Finalizers must be processed by their respective controllers before deletion can complete."
        echo "   Common solutions:"
        echo "   - Wait for controllers to process finalizers"
        echo "   - Check controller logs for errors"
        echo "   - As last resort, manually remove finalizers (DANGEROUS):"
        echo "     kubectl patch $resource_type $resource_name -n ${namespace_args#-n} --type='merge' -p '{\"metadata\":{\"finalizers\":null}}'"
        echo ""
    else
        echo "‚úÖ No finalizers blocking deletion"
        echo ""
    fi

    # Check for owner references
    local owner_refs
    owner_refs=$(kubectl get "$resource_type" "$resource_name" $namespace_args -o jsonpath='{range .metadata.ownerReferences[*]}{.kind}/{.name}{"\n"}{end}' 2>/dev/null)

    if [[ -n "$owner_refs" ]]; then
        echo "üëë OWNER REFERENCES:"
        echo "$owner_refs" | while read -r owner; do
            if [[ -n "$owner" ]]; then
                echo "   ‚Ä¢ Owned by: $owner"

                # Check if owner still exists
                local owner_kind
                local owner_name
                owner_kind=$(echo "$owner" | cut -d'/' -f1)
                owner_name=$(echo "$owner" | cut -d'/' -f2)

                local owner_exists
                owner_exists=$(kubectl get "$owner_kind" "$owner_name" -n "${namespace_args#-n}" -o name 2>/dev/null)
                if [[ -n "$owner_exists" ]]; then
                    local owner_deletion
                    owner_deletion=$(kubectl get "$owner_kind" "$owner_name" -n "${namespace_args#-n}" -o jsonpath='{.metadata.deletionTimestamp}' 2>/dev/null)
                    if [[ -n "$owner_deletion" ]]; then
                        echo "     Status: Owner is also marked for deletion ($owner_deletion)"
                    else
                        echo "     Status: Owner still exists and is NOT marked for deletion"
                    fi
                else
                    echo "     Status: Owner no longer exists"
                fi
            fi
        done
        echo ""
        echo "üí° Resources with owner references are typically deleted when their owner is deleted."
        echo ""
    else
        echo "‚úÖ No owner references"
        echo ""
    fi

    # Check for dependent resources (resources that this one owns)
    local resource_uid
    resource_uid=$(kubectl get "$resource_type" "$resource_name" $namespace_args -o jsonpath='{.metadata.uid}' 2>/dev/null)

    if [[ -n "$resource_uid" ]]; then
        echo "üîó Checking for DEPENDENT RESOURCES..."

        # Get all resources in the namespace that might be owned by this resource
        local dependents=()

        # Common resource types that might have owner references
        local resource_types=("pods" "replicasets" "deployments" "services" "configmaps" "secrets" "persistentvolumeclaims")

        for rt in "${resource_types[@]}"; do
            local owned_resources
            owned_resources=$(kubectl get "$rt" -n "${namespace_args#-n}" -o jsonpath='{range .items[?(@.metadata.ownerReferences[0].uid=="'$resource_uid'")]}{.kind}/{.metadata.name}{"\n"}{end}' 2>/dev/null)

            if [[ -n "$owned_resources" ]]; then
                echo "$owned_resources" | while read -r dep; do
                    if [[ -n "$dep" ]]; then
                        dependents+=("$dep")
                    fi
                done
            fi
        done

        if [[ ${#dependents[@]} -gt 0 ]]; then
            echo "   Found dependent resources:"
            for dep in "${dependents[@]}"; do
                echo "   ‚Ä¢ $dep"
            done
            echo ""
            echo "üí° These dependent resources should be deleted automatically with cascade deletion."
        else
            echo "   ‚úÖ No dependent resources found"
        fi
        echo ""
    fi

    # Final summary and recommendations
    echo "üìã SUMMARY:"

    if [[ -n "$finalizers" ]]; then
        echo "   üî¥ Deletion blocked by finalizers"
        echo "   üéØ Action needed: Wait for controllers to process finalizers or investigate controller issues"
    elif [[ -n "$owner_refs" ]]; then
        echo "   üü° Resource has owner references"
        echo "   üéØ Typically handled automatically when owner is deleted"
    else
        echo "   üü¢ No obvious blockers found"
        echo "   üéØ Resource should complete deletion soon"
    fi

    echo ""
    echo "üîß Useful debugging commands:"
    echo "   kubectl describe $resource_type $resource_name -n ${namespace_args#-n}"
    echo "   kubectl get events -n ${namespace_args#-n} --field-selector involvedObject.name=$resource_name"

    if [[ -n "$finalizers" ]]; then
        echo "   kubectl get $resource_type $resource_name -n ${namespace_args#-n} -o yaml | grep -A5 finalizers"
    fi
}

kgpodsnodes() {
    local namespace="$1"
    
    if [[ -z "$namespace" ]]; then
        echo "Usage: check_namespace_nodes <namespace>"
        echo "Example: check_namespace_nodes web--jobboard"
        return 1
    fi
    
    echo "=== PODS IN NAMESPACE: $namespace ==="
    kubectl get pods -n "$namespace" -o custom-columns=\
"POD NAME:.metadata.name,\
NODE:.spec.nodeName,\
STATUS:.status.phase,\
NODE_LABELS:.spec.nodeSelector"
    
    echo ""
    echo "=== NODE ARCHITECTURES ==="
    
    # Get unique nodes that have pods from this namespace
    local nodes=$(kubectl get pods -n "$namespace" -o jsonpath='{.items[*].spec.nodeName}' | tr ' ' '\n' | sort -u | xargs)
    
    if [[ -z "$nodes" ]]; then
        echo "No pods found in namespace '$namespace' or pods are not scheduled to nodes yet."
        return 1
    fi
    
    kubectl get nodes $nodes \
    -o custom-columns=\
"NODE:.metadata.name,\
ARCH:.metadata.labels.kubernetes\.io/arch,\
INSTANCE:.metadata.labels.node\.kubernetes\.io/instance-type,\
ZONE:.metadata.labels.topology\.kubernetes\.io/zone,\
CAPACITY:.metadata.labels.karpenter\.sh/capacity-type"
}
